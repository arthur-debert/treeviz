#!/bin/bash

# Custom Pre-commit Hook
# ======================
# 
# This script implements a three-phase pre-commit workflow:
# 1. Phase I: Automated fixes (formatters, auto-fixable linters)
# 2. Phase II: Hard checks (tests, strict linters)
# 3. Phase III: Restore stashed changes
#
# Usage:
#   ./scripts/pre-commit                    # Run on staged changes only
#   ./scripts/pre-commit --all-files        # Run on entire codebase
#
# Output behavior:
#   Normal: Shows all output (milestones + tool details)
#   Piped:  Terminal shows milestones, file gets everything

set -euo pipefail

# =============================================================================
# CONFIGURATION AND SETUP
# =============================================================================

# Find project root (where this script is located relative to scripts/)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Parse command line arguments
ALL_FILES=false
if [[ "${1:-}" == "--all-files" ]]; then
    ALL_FILES=true
fi

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Exit codes
EXIT_SUCCESS=0
EXIT_FAILURE=1

# Track overall status
OVERALL_STATUS=$EXIT_SUCCESS
PHASE_I_CHANGES=false
STASH_CREATED=false

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# These log to stderr so they show on terminal even when stdout is piped
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_phase() {
    echo -e "\n${BLUE}=== PHASE $1: $2 ===${NC}" >&2
}

# Check if we have any staged changes
has_staged_changes() {
    ! git diff --cached --quiet
}

# Check if we have any unstaged changes
has_unstaged_changes() {
    ! git diff --quiet
}

# Get staged files by extension
get_staged_files() {
    local extension="$1"
    git diff --cached --name-only --diff-filter=ACM | grep "\\.$extension$" || true
}

# Get all files by extension (for --all-files mode)
get_all_files() {
    local extension="$1"
    find python/ scripts/ -name "*.$extension" 2>/dev/null || true
}

# =============================================================================
# PRE-WORK: STASH UNSTAGED CHANGES (ONLY for staged-only mode)
# =============================================================================

stash_unstaged_changes() {
    if [[ "$ALL_FILES" == "true" ]]; then
        log_info "Running on all files, no stashing needed"
        return
    fi

    if has_unstaged_changes; then
        log_info "Stashing unstaged changes to preserve clean working state"
        git stash push -u -m "pre-commit-unstaged-$(date +%s)" --keep-index
        STASH_CREATED=true
        log_success "Unstaged changes stashed"
    else
        log_info "No unstaged changes to stash"
    fi
}

# =============================================================================
# PHASE I: AUTOMATED FIXES
# =============================================================================

run_phase_i() {
    log_phase "I" "AUTOMATED FIXES"
    
    local phase_i_status=$EXIT_SUCCESS
    
    # Python: Black formatter
    log_info "Running black (Python formatter)..."
    if [[ "$ALL_FILES" == "true" ]]; then
        local py_files
        py_files=$(get_all_files "py")
        if [[ -n "$py_files" ]]; then
            if ! echo "$py_files" | xargs poetry run black --check --diff; then
                log_info "Black would make changes, applying fixes..."
                echo "$py_files" | xargs poetry run black
                PHASE_I_CHANGES=true
            fi
        fi
    else
        local staged_py_files
        staged_py_files=$(get_staged_files "py")
        if [[ -n "$staged_py_files" ]]; then
            if ! echo "$staged_py_files" | xargs poetry run black --check --diff; then
                log_info "Black would make changes, applying fixes..."
                echo "$staged_py_files" | xargs poetry run black
                PHASE_I_CHANGES=true
            fi
        else
            log_info "No staged Python files to format"
        fi
    fi
    
    # Python: Ruff auto-fixable issues
    log_info "Running ruff --fix (Python auto-fixes)..."
    if [[ "$ALL_FILES" == "true" ]]; then
        local py_files
        py_files=$(get_all_files "py")
        if [[ -n "$py_files" ]]; then
            local ruff_output
            ruff_output=$(echo "$py_files" | xargs poetry run ruff check --fix --unsafe-fixes 2>&1 || true)
            if [[ "$ruff_output" != *"All checks passed!"* ]] && [[ -n "$ruff_output" ]]; then
                PHASE_I_CHANGES=true
            fi
        fi
    else
        local staged_py_files
        staged_py_files=$(get_staged_files "py")
        if [[ -n "$staged_py_files" ]]; then
            local ruff_output
            ruff_output=$(echo "$staged_py_files" | xargs poetry run ruff check --fix --unsafe-fixes 2>&1 || true)
            if [[ "$ruff_output" != *"All checks passed!"* ]] && [[ -n "$ruff_output" ]]; then
                PHASE_I_CHANGES=true
            fi
        fi
    fi
    
    # Shell scripts: shfmt formatter
    if command -v shfmt >/dev/null 2>&1; then
        log_info "Running shfmt (Shell formatter)..."
        if [[ "$ALL_FILES" == "true" ]]; then
            local sh_files
            sh_files=$(find scripts/ -name "*.sh" -o -type f -executable | head -20 || true)
            if [[ -n "$sh_files" ]]; then
                if ! echo "$sh_files" | xargs shfmt -d >/dev/null 2>&1; then
                    log_info "shfmt would make changes, applying fixes..."
                    echo "$sh_files" | xargs shfmt -w
                    PHASE_I_CHANGES=true
                fi
            fi
        else
            local staged_sh_files
            staged_sh_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E "\\.(sh|bash)$|^scripts/" || true)
            if [[ -n "$staged_sh_files" ]]; then
                if ! echo "$staged_sh_files" | xargs shfmt -d >/dev/null 2>&1; then
                    log_info "shfmt would make changes, applying fixes..."
                    echo "$staged_sh_files" | xargs shfmt -w
                    PHASE_I_CHANGES=true
                fi
            fi
        fi
    else
        log_info "shfmt not available, skipping shell formatting"
    fi
    
    # Stage any changes made by formatters
    if [[ "$PHASE_I_CHANGES" == "true" ]]; then
        log_info "Staging changes made by automated fixes..."
        if [[ "$ALL_FILES" == "true" ]]; then
            # In --all-files mode, stage ALL changes (including previously unstaged ones)
            git add -A
            log_success "All changes from automated fixes have been staged"
        else
            # In staged-only mode, only stage modifications to already tracked files
            git add -u
            log_success "Changes from automated fixes have been staged"
        fi
    else
        log_info "No automatic fixes needed"
    fi
    
    return $phase_i_status
}

# =============================================================================
# PHASE II: HARD CHECKS
# =============================================================================

run_phase_ii() {
    log_phase "II" "HARD CHECKS"
    
    local phase_ii_status=$EXIT_SUCCESS
    
    # Run tests first (most important check)
    log_info "Running test suite..."
    if ! poetry run pytest python/tests/; then
        log_error "Test suite failed"
        phase_ii_status=$EXIT_FAILURE
    else
        log_success "Test suite passed"
    fi
    
    # Python: Ruff linting (non-fixable issues)
    log_info "Running ruff check (Python linter)..."
    if [[ "$ALL_FILES" == "true" ]]; then
        if ! poetry run ruff check python/ scripts/; then
            log_error "Ruff found linting issues"
            phase_ii_status=$EXIT_FAILURE
        else
            log_success "Ruff checks passed"
        fi
    else
        local staged_py_files
        staged_py_files=$(get_staged_files "py")
        if [[ -n "$staged_py_files" ]]; then
            if ! echo "$staged_py_files" | xargs poetry run ruff check; then
                log_error "Ruff found linting issues in staged files"
                phase_ii_status=$EXIT_FAILURE
            else
                log_success "Ruff checks passed for staged files"
            fi
        else
            log_info "No staged Python files to lint"
        fi
    fi
    
    # Shell scripts: ShellCheck
    if command -v shellcheck >/dev/null 2>&1; then
        log_info "Running shellcheck (Shell linter)..."
        if [[ "$ALL_FILES" == "true" ]]; then
            local sh_files
            sh_files=$(find scripts/ -name "*.sh" -o -type f -executable | head -10 || true)
            if [[ -n "$sh_files" ]]; then
                if ! echo "$sh_files" | xargs shellcheck; then
                    log_warning "ShellCheck found issues (non-blocking)"
                fi
            fi
        else
            local staged_sh_files
            staged_sh_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E "\\.(sh|bash)$|^scripts/" || true)
            if [[ -n "$staged_sh_files" ]]; then
                if ! echo "$staged_sh_files" | xargs shellcheck; then
                    log_warning "ShellCheck found issues in staged files (non-blocking)"
                fi
            fi
        fi
    else
        log_info "shellcheck not available, skipping shell linting"
    fi
    
    # Poetry check (if pyproject.toml changed or in --all-files mode)
    if [[ "$ALL_FILES" == "true" ]] || git diff --cached --name-only | grep -q "pyproject.toml"; then
        log_info "Running poetry check..."
        if ! poetry check; then
            log_error "Poetry check failed"
            phase_ii_status=$EXIT_FAILURE
        else
            log_success "Poetry check passed"
        fi
    fi
    
    return $phase_ii_status
}

# =============================================================================
# PHASE III: RESTORE STASHED CHANGES (ONLY for staged-only mode)
# =============================================================================

restore_stashed_changes() {
    log_phase "III" "RESTORE STASHED CHANGES"
    
    if [[ "$ALL_FILES" == "true" ]]; then
        log_info "Running in --all-files mode, no stashed changes to restore"
        return
    fi
    
    if [[ "$STASH_CREATED" == "true" ]]; then
        log_info "Restoring previously stashed unstaged changes"
        if git stash pop; then
            log_success "Unstaged changes restored"
        else
            log_warning "Could not restore stashed changes - may have conflicts"
            log_info "Use 'git stash list' and 'git stash pop' to resolve manually"
        fi
    else
        log_info "No stashed changes to restore"
    fi
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

main() {
    log_info "Starting custom pre-commit hook"
    log_info "Project root: $PROJECT_ROOT"
    log_info "Mode: $([ "$ALL_FILES" == "true" ] && echo "all files" || echo "staged changes only")"
    
    # Change to project root
    cd "$PROJECT_ROOT"
    
    # Check if we have anything to work with (only in staged-only mode)
    if [[ "$ALL_FILES" == "false" ]] && ! has_staged_changes; then
        log_info "No staged changes found, nothing to check"
        exit $EXIT_SUCCESS
    fi
    
    # PRE-WORK: Stash unstaged changes (only in staged-only mode)
    stash_unstaged_changes
    
    # PHASE I: Automated fixes
    run_phase_i
    
    # PHASE II: Hard checks (run regardless of Phase I status)
    run_phase_ii
    local phase_ii_result=$?
    
    # Update overall status
    if [[ $phase_ii_result -ne 0 ]]; then
        OVERALL_STATUS=$EXIT_FAILURE
    fi
    
    # PHASE III: Restore stashed changes (only in staged-only mode)
    restore_stashed_changes
    
    # Final status report
    echo -e "\n${BLUE}=== FINAL RESULTS ===${NC}" >&2
    if [[ $OVERALL_STATUS -eq 0 ]]; then
        log_success "All checks passed! Commit can proceed."
        if [[ "$PHASE_I_CHANGES" == "true" ]]; then
            if [[ "$ALL_FILES" == "true" ]]; then
                log_info "Note: Files were automatically fixed and all changes have been staged"
            else
                log_info "Note: Some files were automatically fixed and staged"
            fi
        fi
    else
        log_error "Some checks failed. Please fix the issues above before committing."
        if [[ "$PHASE_I_CHANGES" == "true" ]]; then
            if [[ "$ALL_FILES" == "true" ]]; then
                log_info "Note: Files were automatically fixed and all changes have been staged, but other issues remain"
            else
                log_info "Note: Some files were automatically fixed and staged, but other issues remain"
            fi
        fi
    fi
    
    exit $OVERALL_STATUS
}

# Run main function
main "$@"